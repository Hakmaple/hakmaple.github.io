[{"title":"攻防世界Misc-Cat_Jump-Miao合集","url":"https://zer0ptr.github.io/2025/08/12/adworld-Misc-Jump-Cat-miao/","content":"Cat_Jump直接用vscode打开搜索catctf&#123;\n\nMiao~附件内容是一张小猫的图片\n\n分析图片中隐含的内容，得到一个wav文件\n\n在Audacity中打开，查看频谱图，得到密码CatCTF \n\n然后在Deepsound中打开wav文件，得到flag.txt\n工具下载地址：Jpinsoft&#x2F;DeepSound: Official DeepSound repository migrated from jpinsoft.net. DeepSound is a freeware steganography tool and audio converter that hi","date":"2025-08-12","tags":["misc","ctf"],"categories":["misc"]},{"title":"攻防世界Misc-真是阳间题","url":"https://zer0ptr.github.io/2025/08/12/adworld-misc-yangjianti/","content":"附件内容：\n123艾尔登法环正式发售在即，迫不及待的mjj身上好像有蚂蚁在爬，写下了一句谜语：3207357975641587136122466514425152961654613410728337142271750273124995105747053991640817066352343657398947248938255086358418100814441196784643527787764297谜底就是flag，也是他给所有新生的祝福，希望大家享受解码的过程。\n\n先十进制转十六进制\nCTF在线工具-ASCII与进制转换|任意进制转换|ASCII、2进制、8进制、10进制、16进制\n得到十六","date":"2025-08-12","tags":["misc","ctf"],"categories":["misc"]},{"title":"聊聊算法中的时间复杂度","url":"https://zer0ptr.github.io/2025/08/11/%E8%81%8A%E8%81%8A%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","content":"1.什么是时间复杂度时间复杂度是算法复杂度的一个类别(另一个是空间复杂度)，时间复杂度是指执行算法所需要的计算工作量，空间复杂度指执行这个算法所需要的内存空间\n时间复杂度一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度，记为$T(n)$\n一般情况下，算法中基本操作重复执行的次数是问题规模 $n$ 的某个函数，用 $T(n)$ 表示，若有某个辅助函数 $f(n)$ ，使得当 $n$ 趋近于无穷大时，$T(n)&#x2F;f(n)$ 的极限值为不等于零的常数，则称 $f(n)$ 是 $T(n)$ 的同数量级函","date":"2025-08-11","tags":["algorithm"],"categories":["Coding"]},{"title":"P2089 烤鸡","url":"https://zer0ptr.github.io/2025/08/06/luogu-p2089/","content":"Description原题地址：P2089 烤鸡 - 洛谷\n思路：可直接暴力枚举，或者用深度优先搜索\n实现枚举只需要做两层嵌套循环即可：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 枚举题解#include&lt;iostream&gt;  using namespace std;  int main()  &#123;      int a,b,c,d,e,f,g,h,i,j,in,x=0;      ","date":"2025-08-06","tags":["Coding","algorithm"],"categories":["Coding"]},{"title":"Tomcat RCE漏洞CVE-2025-24813复现","url":"https://zer0ptr.github.io/2025/08/05/CVE-2025-24813-Tomcat-RCE/","content":"前置知识JAVA序列化与反序列化简述JAVA序列化是JAVA语言内置的一种对象持久化的机制，它可以将JAVA对象转化为字节流，以便于在网络中进行传输，或者保存到本地进行持久化（类似于PHP序列化）。反序列化则是序列化的逆过程，将字节流转化回JAVA对象。\n序列化过程中，JAVA会将对象的类型、属性以及属性的值等信息一起保存下来，反序列化时，JAVA会根据这些信息重新构建出原来的对象。这就意味着，如果一个恶意用户能够控制序列化的字节流，那么他就有可能在反序列化时构造出含有恶意代码的对象，从而引发安全问题。\nJAVA反序列化漏洞的常见产生原因JAVA反序列化漏洞的产生，主要是因为在反序列化时，JA","date":"2025-08-05","tags":["vuln analysis"],"categories":["vuln analysis"]},{"title":"What is Attention?","url":"https://zer0ptr.github.io/2025/08/01/What-is-Attention/","content":"Attention注意力的来源或许是因为大数据，在大数据中什么样子的数据都有，对于重要的数据我们要使用，对于不太重要的数据我们需要暂时忽略。\n但是对于主流的卷积神经网络(Convolutional Neural Networks, CNN)或短期记忆递归神经网络(Long Short-Term Memory, LSTM)很难去决定什么重要，什么不重要。\n在2017年Google发布 Attention is All You Need 前就已经有人发现了如何在深度学习的模型上做注意力，再后来注意力就诞生了。\n人类的视觉注意力Attention翻译成注意力，从其的命名方式来看，很明显借鉴了人类的注","date":"2025-08-01","tags":["AI","ML","Attention"],"categories":["AI"]},{"title":"P1464与递归函数的记忆化搜索","url":"https://zer0ptr.github.io/2025/07/29/luogu-p1464-memo/","content":"原题地址：https://www.luogu.com.cn/problem/P1464\n\n如果 $a≤0$ 或 $b≤0$ 或 $c≤0$ 就返回值 1\n\n如果 $a&gt;20$ 或 $b&gt;20$ 或 $c&gt;20$ 就返回 w(20,20,20)$\n\n如果 $a&lt;b$ 并且 $b&lt;c$ 就返回 $w(a,b,c−1)+w(a,b−1,c−1)−w(a,b−1,c)$\n\nelse $w(a−1,b,c)+w(a−1,b−1,c)+w(a−1,b,c−1)−w(a−1,b−1,c−1)$\n\n\n注意：例如 $w(30,−1,0)$ 又满足条件 1 又满足条件 2，请按照最上","date":"2025-07-29","tags":["Coding","算法","algorithm"],"categories":["Coding"]},{"title":"Hello World","url":"https://zer0ptr.github.io/2025/07/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo se","date":"2025-07-28","tags":[],"categories":[]},{"title":"What Is Greedy Algorithm","url":"https://zer0ptr.github.io/2025/07/27/what-is-greedy-algorithm/","content":"Description:A greedy algorithm is any algorithm that follows the problem-solving heuristic of making the locally optimal choice at each stage.[1] In many problems, a greedy strategy does not produce an optimal solution, but a greedy heuristic can yield locally optimal solutions that approximate a gl","date":"2025-07-27","tags":["algorithm"],"categories":["Coding"]},{"title":"SWPUCTF2021新生赛Web刷题记录","url":"https://zer0ptr.github.io/2025/07/21/SWPUCTF2021%E6%96%B0%E7%94%9F%E8%B5%9BWeb%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"[SWPUCTF 2021 新生赛]gift_F12Ctrl+U查看前端源码再Ctrl+F搜搜Flag即可\n[SWPUCTF 2021 新生赛]jicao12345678&lt;?phphighlight_file(&#x27;index.php&#x27;);include(&quot;flag.php&quot;);$id=$_POST[&#x27;id&#x27;];$json=json_decode($_GET[&#x27;json&#x27;],true);if ($id==&quot;wllmNB&quot;&amp;&amp;$json[&#x27;x&#x27;]==&quot","date":"2025-07-21","tags":["Web","CTF"],"categories":["CTF"]},{"title":"攻防世界Crypto-babyFibo","url":"https://zer0ptr.github.io/2025/07/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCrypto-babyFibo/","content":"分析附件内容：\n123456789101112131415import osimport libnumfrom secret import flagdef fibo(n):    assert n &gt;= 0    if n &lt; 2:        return n    return fibo(n-1) + fibo(n-2)s = fibo(1000)m = libnum.s2n(flag+os.urandom((len(bin(s))-2)//8-len(flag)))c = m^sprint(c)\n\n\ns是斐波那契数的第1000个数\nm&#x3D;flag+随机数字然后再(S","date":"2025-07-21","tags":["Crypto","CTF"],"categories":["CTF"]},{"title":"攻防世界Crypto-初识RSA","url":"https://zer0ptr.github.io/2025/07/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCrypto-%E5%88%9D%E8%AF%86RSA/","content":"分析附件内容：\n123456789101112131415161718192021222324252627from Crypto.Util.number import bytes_to_long,inverse,getPrimefrom flag import flagm = bytes_to_long(flag)p = getPrime(1024)q = getPrime(1024)n = p*qprint(n)e = 65537c = pow(m,e,n)pq = p*(q-1)qp = q*(p-1)print(&quot;c=&quot;,c)print(&quot;n=&quot;,","date":"2025-07-21","tags":["Crypto","CTF"],"categories":["CTF"]},{"title":"攻防世界Crypto-二元一次方程组","url":"https://zer0ptr.github.io/2025/07/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCrypto-%E4%BA%8C%E5%85%83%E4%B8%80%E6%AC%A1%E6%96%B9%E7%A8%8B%E7%BB%84/","content":"分析：12345678910111213141516171819import libnumfrom Crypto.Util import numberfrom secret import flagsize = 256e = 65537p = number.getPrime(size)q = number.getPrime(size)avg = (p+q)/2n = p*qm = libnum.s2n(flag)c = pow(m, e, n)print(&#x27;n = %d&#x27; % n)print(&#x27;avg = %d&#x27; % avg)print(&#x27;c =","date":"2025-07-21","tags":["Crypto","CTF"],"categories":["CTF"]},{"title":"攻防世界Crypto-baigeiRSA","url":"https://zer0ptr.github.io/2025/07/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCrypto-baigeiRSA/","content":"拿到附件后查看内容12345678910111213141516import libnumfrom Crypto.Util import numberfrom secret import flagsize = 128e = 65537p = number.getPrime(size)q = number.getPrime(size)n = p*qm = libnum.s2n(flag)c = pow(m, e, n)print(&#x27;n = %d&#x27; % n)print(&#x27;c = %d&#x27; % c)\n\n分析参数设置12size = 128e = 65537\n\ns","date":"2025-07-21","tags":["Crypto","CTF"],"categories":["CTF"]},{"title":"深度学习：从头构建神经网络","url":"https://zer0ptr.github.io/2025/07/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E4%BB%8E%E5%A4%B4%E6%9E%84%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","content":"Description本文旨在使用PyTorch构建并训练一个最简单的神经网络，无需添加任何花哨的层或依赖包。\n该模型将足够简单，大家都能使用CPU或GPU来构建和训练。\n这个模型虽然简单，但包含了当前诸如LLM和Stable Diffusions等大型模型所拥有的所有基本元素。\n准备数据假设我们要训练一个具有四个权重并能输出一个数字结果的模型，如下所示：\n$ y &#x3D; w_1 * x_1 + w_2 * x_2 + w_3 * x_3 + w_4 * x_4 $\n我们先生成以下训练数据，假设权重值为 [2,3,4,7]\n12import numpy as npw_list = np.","date":"2025-07-19","tags":["AI","Deep Learning"],"categories":["AI"]},{"title":"动手学深度学习系列01-楔子","url":"https://zer0ptr.github.io/2025/07/18/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%9701-%E6%A5%94%E5%AD%90/","content":"前言大模型建议先从主流开源的Qwen3、Llama3.1上⼿，先快速体验提示词⼯程，然后再学习 LLM模型架构，尝试RAG，跑LoRA微调脚本。\n进一步学习目标：\n\n学习如何从零训练大模型（1B左右规模，预训练+SFT+DPO）\n\n钻研SFT\n• 1）专有任务如Code⽣成、NL2SQL或通⽤NLP的NER、分类、抽取、摘要模型 \n• 2）场景领域微调，⾦融任务LLM、法律LLM、医学LLM、电商LLM \n\n\nLlama系列\\Gemma系列中文增量预训练：先做Llama3.1, 等待Llama4，期望Llama5 \n\nRAG落地：搭建领域问答机器人、知识问答助手\n\n\n大模型学习的思路有两个： ","date":"2025-07-18","tags":["AI"],"categories":["AI"]},{"title":"爱企查无法使用F12问题","url":"https://zer0ptr.github.io/2025/07/17/%E7%88%B1%E4%BC%81%E6%9F%A5%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8F12%E9%97%AE%E9%A2%98/","content":"起因最近突然需要找一下自己爱企查的账号cookie，于是上来一个F12结果发现半天按不出来(刚开始在想是不是键盘的F12坏了，但是换了其他的页面就是正常的) 在B站看到了id为”无名的Coder”大佬的视频在此做个学习记录\nHyperlink: js逆向-爱企查：F12检测绕过，头部参数加密_哔哩哔哩_bilibili\n\n开搞先打开F12（不用管是否正常显示，当然正常显示你就不用继续看了）\n之后 Sources -&gt; Event Listeners Breakprints -&gt; ‘Script’ 国语的话应该是 ‘’源代码’’ -&gt; ‘’事件监听器断点’’ -&gt; ‘’脚","date":"2025-07-17","tags":["Web安全"],"categories":["Web安全"]},{"title":"算法学习-洛谷基础题","url":"https://zer0ptr.github.io/2025/07/13/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%B4%9B%E8%B0%B7%E5%9F%BA%E7%A1%80%E9%A2%98/","content":"三角形面积\n关键：海伦公式\n1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;math.h&gt;double cacu(double a,double b,double c)&#123;    double p=0;    p=0.5*(a+b+c);    return (sqrt(p*(p-a)*(p-b)*(p-c)));&#125;int main(void)&#123;    double a=0,b=0,c=0,S=0;    scanf(&quot;%lf %lf %lf&quot;,&amp;a,&am","date":"2025-07-13","tags":["Coding"],"categories":["Coding"]},{"title":"Web康复训练-攻防世界Web2","url":"https://zer0ptr.github.io/2025/07/12/Web%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb2/","content":"打开题目，给了以下代码：\n12345678910111213141516171819202122&lt;?php$miwen=&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;function encode($str)&#123;    $_o=strrev($str);    // echo $_o;            for($_0=0;$_0&lt;strlen($_o);$_0++)&#123;               $_c=substr($_o,$_0,1);        $_","date":"2025-07-12","tags":["Web安全"],"categories":["Web安全"]},{"title":"关于Python打包成EXE的那些事","url":"https://zer0ptr.github.io/2025/07/12/%E5%85%B3%E4%BA%8EPython%E6%89%93%E5%8C%85%E6%88%90EXE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/","content":"一、为咩要打包Python程序？设想下，你是一位Python开发者，而且你经常将你开发的各类工具分享给你的好朋友们使用，但是你的好朋友可能并不一定是学计算坤的，所以对方可能会没有Python环境也在情理之中，这时候就需要将.py文件打包成.exe可执行文件。常见的应用场景包括：\n\n给非技术人员使用的小工具\n需要保密的商业软件\n方便分发的应用程序\n\n于是在此我将介绍5种打包方式，具体选择哪一种可以根据你的喜好。\n各类打包方式过程和对比方法1：PyInstaller12345678# 安装pip install pyinstaller# 打包命令（基础版）pyinstaller -F -w you","date":"2025-07-12","tags":["Coding"],"categories":["Coding"]},{"title":"How to design an MD5 verifier - 后记","url":"https://zer0ptr.github.io/2025/07/12/verifier-talk/","content":"后记：在MD5-Checker 项目开发中，我也遇到了很多知识面缺陷的问题，于是在开发过程中我选择使用了AI来辅助开发（学艺不精）在此，我根据AI的建议，梳理了一份思路——如何成为一名合格的Devloper\n以下是针对MD5校验工具设计思路所涉及的软件工程原则（以MD5-Checker开发为例）、经典理论以及对应的学习吸收方法的系统化总结：\n\n一、涉及的核心理论与原则1. 模块化设计\nSOLID原则（尤其是单一职责原则）\n每个函数只做一件事（如calculate_md5仅负责计算）\n参考：《Clean Code》by Robert C. Martin\n\n\n关注点分离(SoC)\nCLI解析、业务","date":"2025-07-12","tags":["Coding"],"categories":["Coding"]},{"title":"P1149 [NOIP 2008 提高组] 火柴棒等式","url":"https://zer0ptr.github.io/2025/07/12/P1149-Matchstick/","content":"题目地址： https://www.luogu.com.cn/problem/P1149\nSolution:分析：一道暴力枚举题，先枚举出 A 和 B 所有可能的数字，设$f_&#123;i&#125;$ 表示拼成数字 i 所用的火柴数，若$f_{A}+f_{B}+f_{A+B}&#x3D;n−4$，答案加一，这里减 4 是减去加号和等号所用火柴。\n因为n的范围是n(1≤n≤24)，因此枚举总量不会太大，大致枚举到1000就可以了。\nAC Code:\n123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace","date":"2025-07-12","tags":["算法"],"categories":["算法"]},{"title":"Linux下8086汇编语言环境搭建","url":"https://zer0ptr.github.io/2025/07/11/Linux%E4%B8%8B8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"Description:dosbox是一个免费开源跨平台的MS-DOS模拟器。用它可以编译运行8086汇编\n1sudo apt-get install dosbox\n\n如图所示已成功安装dosbox\n接下来挂载驱动器C盘并进入C盘：\n12Z:\\&gt;mount c /home/zhailin/ASM-TestZ:\\&gt;c:\n\n\n如上图成功将linux下的路径”&#x2F;home&#x2F;ubuntu&#x2F;masm&#x2F;“这个路径挂载为dosbox虚拟机的序盘，并进入到了c盘\n虚拟机安装之后，进行汇编开发学习还需要masm、link、debug三个工具；其中masm是汇编工","date":"2025-07-11","tags":["asm"],"categories":["底层"]},{"title":"How to design an MD5 verifier","url":"https://zer0ptr.github.io/2025/07/11/md5verifier-20250711/","content":"项目地址：https://github.com/fishcanf1y/MD5-Checker\nDescription:MD5 校验器用于验证数据完整性和检测数据是否被篡改，常用于文件下载、软件更新、密码存储等场景。它可以快速生成文件的“数字指纹”——MD5 值，然后将该值与原始值进行比较，以确保文件在传输或存储过程中没有发生变化。﻿\n以下是MD5 校验器的主要用途和优势：\n\n文件完整性验证:\n当下载文件时，网站通常会提供文件的MD5 值。下载完成后，用户可以使用MD5 校验器计算下载文件的MD5 值，并与提供的MD5 值进行比较。如果两者一致，则表示文件没有损坏或被篡改；如果不一致，则表示文件","date":"2025-07-11","tags":["Coding"],"categories":["Coding"]},{"title":"Go基础语法学习笔记","url":"https://zer0ptr.github.io/2025/07/11/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"Tips: 新手向文章，其中涉及的代码你可以在 Https://github.com/fishcanf1y/Programming=Learning/Golang/ 中找到\nHello World：1234567package main  import &quot;fmt&quot;    func main() &#123;      fmt.Printf(&quot;Hello World\\n&quot;)      // go run hello.go&#125;\n\n\n在第一行代码中 package main 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：pack","date":"2025-07-11","tags":["Coding"],"categories":["Coding"]},{"title":"攻防世界Crypto-了不起的盖茨比","url":"https://zer0ptr.github.io/2025/07/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCrypto-%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84%E7%9B%96%E8%8C%A8%E6%AF%94/","content":"Description:小王读了盖茨比深受震撼，于是摘录本书并效仿原作者为你加密留了一段言，但他忘记给你iv了，请问你可以恢复出来原文吗(得到的flag内容用CatCTF{}包上提交)\n附件内容为python源代码程序，对其进行分析：\n123456789101112131415161718192021222324252627282930313233from Crypto.Cipher import AES  from Crypto.Util.strxor import strxor as xor  from Crypto.Util.Padding import pad  from random","date":"2025-07-10","tags":[],"categories":[]},{"title":"Many Time Pad Attack","url":"https://zer0ptr.github.io/2025/06/22/Many-Time-Pad-Attack/","content":"一些基础知识符号：\n⊕ 代表异或\nC1 代表密文\nM1 代表明文\n性质：\n\n交换律\n结合律 (a ⊕ b ) ⊕ c &#x3D; a⊕ ( b ⊕ c)\n任何数x x ⊕ x &#x3D; 0 x ⊕ 0 &#x3D; X\n自反性 x ⊕ b ⊕ b &#x3D; x ⊕ 0 &#x3D; x\n\nDescriptionMany-Time-Pad (多时间垫) 攻击是一种针对多次使用相同密钥的流密码（如一次性密码本，One-Time Pad）的密码分析技术。其核心原理是利用密钥重用导致的明文信息泄露，通过数学和统计方法恢复部分或全部明文。以下是其核心原理和步骤：\n1. 一次性密码本（OTP）的","date":"2025-06-22","tags":["Crypto"],"categories":["Crypto"]},{"title":"攻防世界Crypto-cat's gift","url":"https://zer0ptr.github.io/2025/06/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCrypto-cat's%20gift/","content":"Description:如图所示，下面这只好心的猫猫给你送来了跨年礼物。由于礼物不好拿，所以猫猫把礼物平均分成了四份，但是其中一份不小心掉在地上散落成了无数片，变成了 1 - 1&#x2F;3 + 1&#x2F;5 - 1&#x2F;7 + …\n聪明的你能算出或猜出猫猫的礼物是什么吗？  \nflag示例: CatCTF&#123;apple&#125; CatCTF&#123;banana&#125;\n关键：Gregory-Leibniz 公式德国数学家莱布尼茨（Leibniz）于 1674 年曾提出 Gregory-Leibniz 公式来计算π：$π &#x2F; 4 &#x3D; 1 − ","date":"2025-06-22","tags":["Crypto","CTF"],"categories":["CTF"]},{"title":"upload-labs靶场小计","url":"https://zer0ptr.github.io/2025/06/17/upload-labs%E9%9D%B6%E5%9C%BA%E5%B0%8F%E8%AE%A1/","content":"Introduction：\nRepo Address: https://github.com/c0ny1/upload-labs\nDescription：upload-labs是一个使用php语言编写的，专门收集渗透测试和CTF中遇到的各种上传漏洞的靶场。旨在帮助大家对上传漏洞有一个全面的了解。目前一共20关，每一关都包含着不同上传方式。\n\n正文开始Pass-01源码分析:\n123456789101112131415161718function checkFile() &#123;    var file = document.getElementsByName(&#x27;upload_fi","date":"2025-06-17","tags":["Web安全"],"categories":["Web安全"]},{"title":"记一次与Fibonacci斗智斗勇","url":"https://zer0ptr.github.io/2025/05/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8EFibonacci%E6%96%97%E6%99%BA%E6%96%97%E5%8B%87/","content":"楔子：事必有因。近时方备战粤港澳信息学竞赛，适值主办方有其平台，故欲以其平台练题。然用之颇觉不堪，譬如一题所予提示甚少，题目分类未明，且大多无题解。此题吾亦屡试方解出，遂作此文，以便后学及自我温习。\n那首先来看看这题目和出题人究竟时何方神圣\n题目描述：LQ1005:入门训练Fibonacci数列知识点:简单递归 C++-运算符和表达式概念\nFibonacci数列的递推公式为:Fn&#x3D;Fn-1+Fn-2,其中F1&#x3D;F2&#x3D;1。当n比较大时,Fn也非常大,现在我们想知道,Fn除以10007的余数是多少。\n输入格式输入描述:输入包含一个整数n。输入样例:\n110\n输出格式输","date":"2025-05-17","tags":["算法"],"categories":["算法"]},{"title":"由一道题引发对DFS的思考","url":"https://zer0ptr.github.io/2025/05/17/NOIP-2002-%E6%99%AE%E5%8F%8A%E7%BB%84-%E9%80%89%E6%95%B0/","content":"[NOIP 2002 普及组] 选数感觉过于标题的意思了，其实是由这道题来引出深度优先搜索(DFS)\n首先看看题目描述：题目描述已知 $\\large n$ 个整数 $x_1,x_2,\\cdots,x_n$，以及$1$个整数$k$($k&lt;n$)。从$n$ 个整数中任选 $k$个整数相加，可分别得到一系列的和。例如当$n&#x3D;4$，$k&#x3D;3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：\n$3+7+12&#x3D;22$\n$3+7+19&#x3D;29$\n$7+12+19&#x3D;38$\n$3+12+19&#x3D;34$\n现在，要求你计算","date":"2025-05-17","tags":["算法"],"categories":["算法"]},{"title":"Basic ROP Learning","url":"https://zer0ptr.github.io/2025/04/19/Basic-ROP-Learning/","content":"Basic-ROP-LearningROP(Return-Oriented Programming)概述ROP(Return-Oriented Programming)是一种高级的代码复用攻击技术，主要用于绕过现代操作系统的安全防护机制（如DEP&#x2F;NX）。其核心思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。\n1. 基本概念（1）产生背景\nDEP&#x2F;NX防护：现代系统禁止执行栈&#x2F;堆上的代码（数据执行保护）。\n\nASLR防护：随机化内存布局，增加预测难度。\n\nROP应对方案：复用已有代码（","date":"2025-04-19","tags":["Pwn"],"categories":["Pwn"]},{"title":"条件竞争漏洞学习","url":"https://zer0ptr.github.io/2025/02/08/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/","content":"Web安全条件竞争漏洞学习0x00 概述​\t\t条件竞争漏洞发生在多个线程同时访问同一个共享代码、变量、文件等，，由于多个不同线程同时与相同的数据进行交互，从而导致碰撞冲突（例如，后端多个线程同时修改数据库中的某一个字段值）。攻击者通过精心定制请求到达后端的时间故意制造冲突，并由此实现恶意目的。这个漏洞存在于操作系统、数据库、web等多个层面，由于大多服务端框架在处理不同用户的请求时是并发进行的，而开发者在进行代码开发时常常倾向于认为代码会以线性的方式执行，而忽视了并行服务器会并发执行多个线程，这就会导致意想不到的结果。\n简单来说，就是多线程同时操作一个对象，而没有对对象进行加锁等保证一致性的操","date":"2025-02-08","tags":["Web安全"],"categories":["Web安全"]},{"title":"攻防世界-pwnstack题解","url":"https://zer0ptr.github.io/2025/02/06/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwnstack%E9%A2%98%E8%A7%A3/","content":"攻防世界-pwnstack题解一、简述【题型】PWN【题目】pwnstack【来源】[攻防世界](https://adworld.xctf.org.cn/challenges/list）【思路】栈溢出\n二、思路及过程Step.1：先使用checksec和file了解有关这个文件的一些信息\n12345678910111213# zer0-r1ng @ ring0rez-Laptop in ~/Challenge/Adworld/pwnstack/[16:27:17]$ checksec pwn2[*] &#x27;/Challenge/Adworld/pwnstack/pwn2&#x27;   ","date":"2025-02-06","tags":["Pwn","CTF"],"categories":["CTF"]}]